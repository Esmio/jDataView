{"version":3,"file":null,"sources":["/Users/rreverser/oss/jDataView/src/jdataview.js"],"sourcesContent":["var ctx = BROWSER ? self : global;\n\nvar compatibility = {\n\t// NodeJS Buffer in v0.5.5 and newer\n\tNodeBuffer: NODE && 'Buffer' in ctx,\n\tDataView: 'DataView' in ctx,\n\tArrayBuffer: 'ArrayBuffer' in ctx,\n\tPixelData: BROWSER && 'CanvasPixelArray' in ctx && !('Uint8ClampedArray' in ctx) && 'document' in ctx\n};\n\nvar TextEncoder = ctx.TextEncoder;\nvar TextDecoder = ctx.TextDecoder;\n\n// we don't want to bother with old Buffer implementation\nif (NODE && compatibility.NodeBuffer) {\n\t(function (buffer) {\n\t\ttry {\n\t\t\tbuffer.writeFloatLE(Infinity, 0);\n\t\t} catch (e) {\n\t\t\tcompatibility.NodeBuffer = false;\n\t\t}\n\t})(new Buffer(4));\n}\n\nif (BROWSER && compatibility.PixelData) {\n\tvar context2d = document.createElement('canvas').getContext('2d');\n\tvar createPixelData = function (byteLength, buffer) {\n\t\tvar data = context2d.createImageData((byteLength + 3) / 4, 1).data;\n\t\tdata.byteLength = byteLength;\n\t\tif (buffer !== undefined) {\n\t\t\tfor (var i = 0; i < byteLength; i++) {\n\t\t\t\tdata[i] = buffer[i];\n\t\t\t}\n\t\t}\n\t\treturn data;\n\t};\n}\n\nvar dataTypes = {\n\t'Int8': 1,\n\t'Int16': 2,\n\t'Int32': 4,\n\t'Uint8': 1,\n\t'Uint16': 2,\n\t'Uint32': 4,\n\t'Float32': 4,\n\t'Float64': 8\n};\n\nfunction is(obj, Ctor) {\n\tif (typeof obj !== 'object' || obj === null) {\n\t\treturn false;\n\t}\n\treturn obj.constructor === Ctor || Object.prototype.toString.call(obj) === '[object ' + Ctor.name + ']';\n}\n\nfunction arrayFrom(arrayLike, forceCopy) {\n\treturn (!forceCopy && is(arrayLike, Array)) ? arrayLike : Array.prototype.slice.call(arrayLike);\n}\n\nfunction defined(value, defaultValue) {\n\treturn value !== undefined ? value : defaultValue;\n}\n\nexport default function jDataView(buffer, byteOffset, byteLength, littleEndian) {\n\t/* jshint validthis:true */\n\n\tif (jDataView.is(buffer)) {\n\t\tvar result = buffer.slice(byteOffset, byteOffset + byteLength);\n\t\tresult._littleEndian = defined(littleEndian, result._littleEndian);\n\t\treturn result;\n\t}\n\n\tif (!jDataView.is(this)) {\n\t\treturn new jDataView(buffer, byteOffset, byteLength, littleEndian);\n\t}\n\n\tthis.buffer = buffer = jDataView.wrapBuffer(buffer);\n\n\t// Check parameters and existing functionnalities\n\tthis._isArrayBuffer = compatibility.ArrayBuffer && is(buffer, ArrayBuffer);\n\tthis._isPixelData = BROWSER && compatibility.PixelData && is(buffer, CanvasPixelArray);\n\tthis._isDataView = compatibility.DataView && this._isArrayBuffer;\n\tthis._isNodeBuffer = NODE && compatibility.NodeBuffer && Buffer.isBuffer(buffer);\n\n\t// Handle Type Errors\n\tif (!(NODE && this._isNodeBuffer) && !this._isArrayBuffer && !(BROWSER && this._isPixelData) && !is(buffer, Array)) {\n\t\tthrow new TypeError('jDataView buffer has an incompatible type');\n\t}\n\n\t// Default Values\n\tthis._littleEndian = !!littleEndian;\n\n\tvar bufferLength = 'byteLength' in buffer ? buffer.byteLength : buffer.length;\n\tthis.byteOffset = byteOffset = defined(byteOffset, 0);\n\tthis.byteLength = byteLength = defined(byteLength, bufferLength - byteOffset);\n\n\tthis._offset = this._bitOffset = 0;\n\n\tif (!this._isDataView) {\n\t\tthis._checkBounds(byteOffset, byteLength, bufferLength);\n\t} else {\n\t\tthis._view = new DataView(buffer, byteOffset, byteLength);\n\t}\n\n\t// Create uniform methods (action wrappers) for the following data types\n\n\tthis._engineAction =\n\t\tthis._isDataView\n\t\t\t? this._dataViewAction\n\t\t: (NODE && this._isNodeBuffer)\n\t\t\t? this._nodeBufferAction\n\t\t: this._isArrayBuffer\n\t\t\t? this._arrayBufferAction\n\t\t: this._arrayAction;\n}\n\nfunction getCharCodes(string) {\n\tif (NODE && compatibility.NodeBuffer) {\n\t\treturn new Buffer(string, 'binary');\n\t}\n\n\tvar Type = compatibility.ArrayBuffer ? Uint8Array : Array,\n\t\tcodes = new Type(string.length);\n\n\tfor (var i = 0, length = string.length; i < length; i++) {\n\t\tcodes[i] = string.charCodeAt(i) & 0xff;\n\t}\n\treturn codes;\n}\n\n// mostly internal function for wrapping any supported input (String or Array-like) to best suitable buffer format\njDataView.wrapBuffer = function (buffer) {\n\tswitch (typeof buffer) {\n\t\tcase 'number':\n\t\t\tif (NODE && compatibility.NodeBuffer) {\n\t\t\t\tbuffer = new Buffer(buffer);\n\t\t\t\tbuffer.fill(0);\n\t\t\t} else\n\t\t\tif (compatibility.ArrayBuffer) {\n\t\t\t\tbuffer = new Uint8Array(buffer).buffer;\n\t\t\t} else\n\t\t\tif (BROWSER && compatibility.PixelData) {\n\t\t\t\tbuffer = createPixelData(buffer);\n\t\t\t} else {\n\t\t\t\tbuffer = new Array(buffer);\n\t\t\t\tfor (var i = 0; i < buffer.length; i++) {\n\t\t\t\t\tbuffer[i] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn buffer;\n\n\t\tcase 'string':\n\t\t\tbuffer = getCharCodes(buffer);\n\t\t\t/* falls through */\n\t\tdefault:\n\t\t\tif ('length' in buffer && !(\n\t\t\t\t(NODE && compatibility.NodeBuffer && Buffer.isBuffer(buffer)) ||\n\t\t\t\t(compatibility.ArrayBuffer && is(buffer, ArrayBuffer)) ||\n\t\t\t\t(BROWSER && compatibility.PixelData && is(buffer, CanvasPixelArray))\n\t\t\t)) {\n\t\t\t\tif (NODE && compatibility.NodeBuffer) {\n\t\t\t\t\tbuffer = new Buffer(buffer);\n\t\t\t\t} else\n\t\t\t\tif (compatibility.ArrayBuffer) {\n\t\t\t\t\tif (!is(buffer, ArrayBuffer)) {\n\t\t\t\t\t\tbuffer = new Uint8Array(buffer).buffer;\n\t\t\t\t\t\t// bug in Node.js <= 0.8:\n\t\t\t\t\t\tif (!is(buffer, ArrayBuffer)) {\n\t\t\t\t\t\t\tbuffer = new Uint8Array(arrayFrom(buffer, true)).buffer;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\tif (BROWSER && compatibility.PixelData) {\n\t\t\t\t\tbuffer = createPixelData(buffer.length, buffer);\n\t\t\t\t} else {\n\t\t\t\t\tbuffer = arrayFrom(buffer);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn buffer;\n\t}\n};\n\nfunction pow2(n) {\n\treturn (n >= 0 && n < 31) ? (1 << n) : (pow2[n] || (pow2[n] = Math.pow(2, n)));\n}\n\njDataView.is = function (view) {\n\treturn view && view.jDataView;\n};\n\njDataView.from = function () {\n\treturn new jDataView(arguments);\n};\n\nfunction Uint64(lo, hi) {\n\tthis.lo = lo;\n\tthis.hi = hi;\n}\n\njDataView.Uint64 = Uint64;\n\nUint64.prototype.valueOf = function () {\n\treturn this.lo + pow2(32) * this.hi;\n};\n\nUint64.fromNumber = function (number) {\n\tvar hi = Math.floor(number / pow2(32)),\n\t\tlo = number - hi * pow2(32);\n\n\treturn new Uint64(lo, hi);\n};\n\nfunction Int64(lo, hi) {\n\tUint64.apply(this, arguments);\n}\n\njDataView.Int64 = Int64;\n\nInt64.prototype = 'create' in Object ? Object.create(Uint64.prototype) : new Uint64();\n\nInt64.prototype.valueOf = function () {\n\tif (this.hi < pow2(31)) {\n\t\treturn Uint64.prototype.valueOf.apply(this, arguments);\n\t}\n\treturn -((pow2(32) - this.lo) + pow2(32) * (pow2(32) - 1 - this.hi));\n};\n\nInt64.fromNumber = function (number) {\n\tvar lo, hi;\n\tif (number >= 0) {\n\t\tvar unsigned = Uint64.fromNumber(number);\n\t\tlo = unsigned.lo;\n\t\thi = unsigned.hi;\n\t} else {\n\t\thi = Math.floor(number / pow2(32));\n\t\tlo = number - hi * pow2(32);\n\t\thi += pow2(32);\n\t}\n\treturn new Int64(lo, hi);\n};\n\n// Helper functions for Uint64.prototype.toString\n\n// e.g. 1234 -> [4, 3, 2, 1]\nfunction numToDigits(num) {\n\tvar digits = num.toString().split('');\n\tfor (var i = 0; i < digits.length; i++) {\n\t\tdigits[i] = +digits[i];\n\t}\n\tdigits.reverse();\n\treturn digits;\n}\n\n// Adds two digit arrays, returning the result.\nfunction add(x, y) {\n\tvar z = [];\n\tvar n = Math.max(x.length, y.length);\n\tvar carry = 0;\n\tvar i = 0;\n\twhile (i < n || carry) {\n\t\tvar xi = i < x.length ? x[i] : 0;\n\t\tvar yi = i < y.length ? y[i] : 0;\n\t\tvar zi = carry + xi + yi;\n\t\tz.push(zi % 10);\n\t\tcarry = Math.floor(zi / 10);\n\t\ti++;\n\t}\n\treturn z;\n}\n\n// Precise versions of toString() for Int64/Uint64\n\nUint64.prototype.toString = function() {\n\t// Faster toString() for numbers which can be represented precisely as floats.\n\tif (this.hi < pow2(19)) {\n\t\treturn Number.prototype.toString.apply(this.valueOf(), arguments);\n\t}\n\n\t// This converts the numbers to base 10 digit arrays for arbitrary precision toString().\n\t// See http://www.danvk.org/hex2dec.html\n\n\n\t// Compute result = 2^32 * hi + lo\n\tvar hiArray = numToDigits(this.hi);\n\tvar loArray = numToDigits(this.lo);\n\tfor (var i = 0; i < 32; i++) {\n\t\thiArray = add(hiArray, hiArray, 10);\n\t}\n\tvar result = add(hiArray, loArray, 10);\n\n\tvar str = '';\n\tfor (i = result.length - 1; i >= 0; i--) {\n\t\tstr += result[i];\n\t}\n\treturn str;\n};\n\nInt64.prototype.toString = function() {\n\tif (this.hi < pow2(31)) {\n\t\treturn Uint64.prototype.toString.apply(this, arguments);\n\t}\n\tif (this.hi > pow2(32) - 1 - pow2(19)) {\n\t\treturn Number.prototype.toString.apply(this.valueOf(), arguments);\n\t}\n\treturn '-' + new Uint64((pow2(32) - this.lo), (pow2(32) - 1 - this.hi)).toString();\n};\n\n\nvar proto = jDataView.prototype = {\n\tcompatibility: compatibility,\n\tjDataView: true,\n\n\t_checkBounds: function (byteOffset, byteLength, maxLength) {\n\t\t// Do additional checks to simulate DataView\n\t\tif (typeof byteOffset !== 'number') {\n\t\t\tthrow new TypeError('Offset is not a number.');\n\t\t}\n\t\tif (typeof byteLength !== 'number') {\n\t\t\tthrow new TypeError('Size is not a number.');\n\t\t}\n\t\tif (byteLength < 0) {\n\t\t\tthrow new RangeError('Length is negative.');\n\t\t}\n\t\tif (byteOffset < 0 || byteOffset + byteLength > defined(maxLength, this.byteLength)) {\n\t\t\tthrow new RangeError('Offsets are out of bounds.');\n\t\t}\n\t},\n\n\t_action: function (type, isReadAction, byteOffset, littleEndian, value) {\n\t\treturn this._engineAction(\n\t\t\ttype,\n\t\t\tisReadAction,\n\t\t\tdefined(byteOffset, this._offset),\n\t\t\tdefined(littleEndian, this._littleEndian),\n\t\t\tvalue\n\t\t);\n\t},\n\n\t_dataViewAction: function (type, isReadAction, byteOffset, littleEndian, value) {\n\t\t// Move the internal offset forward\n\t\tthis._offset = byteOffset + dataTypes[type];\n\t\treturn isReadAction ? this._view['get' + type](byteOffset, littleEndian) : this._view['set' + type](byteOffset, value, littleEndian);\n\t},\n\n\t_arrayBufferAction: function (type, isReadAction, byteOffset, littleEndian, value) {\n\t\tvar size = dataTypes[type], TypedArray = ctx[type + 'Array'], typedArray;\n\n\t\tlittleEndian = defined(littleEndian, this._littleEndian);\n\n\t\t// ArrayBuffer: we use a typed array of size 1 from original buffer if alignment is good and from slice when it's not\n\t\tif (size === 1 || ((this.byteOffset + byteOffset) % size === 0 && littleEndian)) {\n\t\t\ttypedArray = new TypedArray(this.buffer, this.byteOffset + byteOffset, 1);\n\t\t\tthis._offset = byteOffset + size;\n\t\t\treturn isReadAction ? typedArray[0] : (typedArray[0] = value);\n\t\t} else {\n\t\t\tvar bytes = new Uint8Array(isReadAction ? this.getBytes(size, byteOffset, littleEndian, true) : size);\n\t\t\ttypedArray = new TypedArray(bytes.buffer, 0, 1);\n\n\t\t\tif (isReadAction) {\n\t\t\t\treturn typedArray[0];\n\t\t\t} else {\n\t\t\t\ttypedArray[0] = value;\n\t\t\t\tthis._setBytes(byteOffset, bytes, littleEndian);\n\t\t\t}\n\t\t}\n\t},\n\n\t_arrayAction: function (type, isReadAction, byteOffset, littleEndian, value) {\n\t\treturn isReadAction ? this['_get' + type](byteOffset, littleEndian) : this['_set' + type](byteOffset, value, littleEndian);\n\t},\n\n\t// Helpers\n\n\t_getBytes: function (length, byteOffset, littleEndian) {\n\t\tlittleEndian = defined(littleEndian, this._littleEndian);\n\t\tbyteOffset = defined(byteOffset, this._offset);\n\t\tlength = defined(length, this.byteLength - byteOffset);\n\n\t\tthis._checkBounds(byteOffset, length);\n\n\t\tbyteOffset += this.byteOffset;\n\n\t\tthis._offset = byteOffset - this.byteOffset + length;\n\n\t\tvar result = (\n\t\t\tthis._isArrayBuffer\n\t\t\t? new Uint8Array(this.buffer, byteOffset, length)\n\t\t\t: (this.buffer.slice || Array.prototype.slice).call(this.buffer, byteOffset, byteOffset + length)\n\t\t);\n\n\t\treturn littleEndian || length <= 1 ? result : arrayFrom(result).reverse();\n\t},\n\n\t// wrapper for external calls (do not return inner buffer directly to prevent it's modifying)\n\tgetBytes: function (length, byteOffset, littleEndian, toArray) {\n\t\tvar result = this._getBytes(length, byteOffset, defined(littleEndian, true));\n\t\treturn toArray ? arrayFrom(result) : result;\n\t},\n\n\t_setBytes: function (byteOffset, bytes, littleEndian) {\n\t\tvar length = bytes.length;\n\n\t\t// needed for Opera\n\t\tif (length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tlittleEndian = defined(littleEndian, this._littleEndian);\n\t\tbyteOffset = defined(byteOffset, this._offset);\n\n\t\tthis._checkBounds(byteOffset, length);\n\n\t\tif (!littleEndian && length > 1) {\n\t\t\tbytes = arrayFrom(bytes, true).reverse();\n\t\t}\n\n\t\tbyteOffset += this.byteOffset;\n\n\t\tif (this._isArrayBuffer) {\n\t\t\tnew Uint8Array(this.buffer, byteOffset, length).set(bytes);\n\t\t}\n\t\telse {\n\t\t\tif (NODE && this._isNodeBuffer) {\n\t\t\t\tnew Buffer(bytes).copy(this.buffer, byteOffset);\n\t\t\t} else {\n\t\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\t\tthis.buffer[byteOffset + i] = bytes[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis._offset = byteOffset - this.byteOffset + length;\n\t},\n\n\tsetBytes: function (byteOffset, bytes, littleEndian) {\n\t\tthis._setBytes(byteOffset, bytes, defined(littleEndian, true));\n\t},\n\n\tgetString: function (byteLength, byteOffset, encoding) {\n\t\tif (NODE && this._isNodeBuffer) {\n\t\t\tbyteOffset = defined(byteOffset, this._offset);\n\t\t\tbyteLength = defined(byteLength, this.byteLength - byteOffset);\n\n\t\t\tthis._checkBounds(byteOffset, byteLength);\n\n\t\t\tthis._offset = byteOffset + byteLength;\n\t\t\treturn this.buffer.toString(encoding || 'binary', this.byteOffset + byteOffset, this.byteOffset + this._offset);\n\t\t}\n\t\tvar bytes = this._getBytes(byteLength, byteOffset, true);\n\t\t// backward-compatibility\n\t\tencoding = encoding === 'utf8' ? 'utf-8' : (encoding || 'binary');\n\t\tif (TextDecoder && encoding !== 'binary') {\n\t\t\treturn new TextDecoder(encoding).decode(this._isArrayBuffer ? bytes : new Uint8Array(bytes));\n\t\t}\n\t\tvar string = '';\n\t\tbyteLength = bytes.length;\n\t\tfor (var i = 0; i < byteLength; i++) {\n\t\t\tstring += String.fromCharCode(bytes[i]);\n\t\t}\n\t\tif (encoding === 'utf-8') {\n\t\t\tstring = decodeURIComponent(escape(string));\n\t\t}\n\t\treturn string;\n\t},\n\n\tsetString: function (byteOffset, subString, encoding) {\n\t\tif (NODE && this._isNodeBuffer) {\n\t\t\tbyteOffset = defined(byteOffset, this._offset);\n\t\t\tthis._checkBounds(byteOffset, subString.length);\n\t\t\tthis._offset = byteOffset + this.buffer.write(subString, this.byteOffset + byteOffset, encoding || 'binary');\n\t\t\treturn;\n\t\t}\n\t\t// backward-compatibility\n\t\tencoding = encoding === 'utf8' ? 'utf-8' : (encoding || 'binary');\n\t\tvar bytes;\n\t\tif (TextEncoder && encoding !== 'binary') {\n\t\t\tbytes = new TextEncoder(encoding).encode(subString);\n\t\t} else {\n\t\t\tif (encoding === 'utf-8') {\n\t\t\t\tsubString = unescape(encodeURIComponent(subString));\n\t\t\t}\n\t\t\tbytes = getCharCodes(subString);\n\t\t}\n\t\tthis._setBytes(byteOffset, bytes, true);\n\t},\n\n\tgetChar: function (byteOffset) {\n\t\treturn this.getString(1, byteOffset);\n\t},\n\n\tsetChar: function (byteOffset, character) {\n\t\tthis.setString(byteOffset, character);\n\t},\n\n\ttell: function () {\n\t\treturn this._offset;\n\t},\n\n\tseek: function (byteOffset) {\n\t\tthis._checkBounds(byteOffset, 0);\n\t\t/* jshint boss: true */\n\t\treturn this._offset = byteOffset;\n\t},\n\n\tskip: function (byteLength) {\n\t\treturn this.seek(this._offset + byteLength);\n\t},\n\n\tslice: function (start, end, forceCopy) {\n\t\tfunction normalizeOffset(offset, byteLength) {\n\t\t\treturn offset < 0 ? offset + byteLength : offset;\n\t\t}\n\n\t\tstart = normalizeOffset(start, this.byteLength);\n\t\tend = normalizeOffset(defined(end, this.byteLength), this.byteLength);\n\n\t\treturn (\n\t\t\tforceCopy\n\t\t\t? new jDataView(this.getBytes(end - start, start, true, true), undefined, undefined, this._littleEndian)\n\t\t\t: new jDataView(this.buffer, this.byteOffset + start, end - start, this._littleEndian)\n\t\t);\n\t},\n\n\talignBy: function (byteCount) {\n\t\tthis._bitOffset = 0;\n\t\tif (defined(byteCount, 1) !== 1) {\n\t\t\treturn this.skip(byteCount - (this._offset % byteCount || byteCount));\n\t\t} else {\n\t\t\treturn this._offset;\n\t\t}\n\t},\n\n\t// Compatibility functions\n\n\t_getFloat64: function (byteOffset, littleEndian) {\n\t\tvar b = this._getBytes(8, byteOffset, littleEndian),\n\n\t\t\tsign = 1 - (2 * (b[7] >> 7)),\n\t\t\texponent = ((((b[7] << 1) & 0xff) << 3) | (b[6] >> 4)) - ((1 << 10) - 1),\n\n\t\t// Binary operators such as | and << operate on 32 bit values, using + and Math.pow(2) instead\n\t\t\tmantissa = ((b[6] & 0x0f) * pow2(48)) + (b[5] * pow2(40)) + (b[4] * pow2(32)) +\n\t\t\t\t\t\t(b[3] * pow2(24)) + (b[2] * pow2(16)) + (b[1] * pow2(8)) + b[0];\n\n\t\tif (exponent === 1024) {\n\t\t\tif (mantissa !== 0) {\n\t\t\t\treturn NaN;\n\t\t\t} else {\n\t\t\t\treturn sign * Infinity;\n\t\t\t}\n\t\t}\n\n\t\tif (exponent === -1023) { // Denormalized\n\t\t\treturn sign * mantissa * pow2(-1022 - 52);\n\t\t}\n\n\t\treturn sign * (1 + mantissa * pow2(-52)) * pow2(exponent);\n\t},\n\n\t_getFloat32: function (byteOffset, littleEndian) {\n\t\tvar b = this._getBytes(4, byteOffset, littleEndian),\n\n\t\t\tsign = 1 - (2 * (b[3] >> 7)),\n\t\t\texponent = (((b[3] << 1) & 0xff) | (b[2] >> 7)) - 127,\n\t\t\tmantissa = ((b[2] & 0x7f) << 16) | (b[1] << 8) | b[0];\n\n\t\tif (exponent === 128) {\n\t\t\tif (mantissa !== 0) {\n\t\t\t\treturn NaN;\n\t\t\t} else {\n\t\t\t\treturn sign * Infinity;\n\t\t\t}\n\t\t}\n\n\t\tif (exponent === -127) { // Denormalized\n\t\t\treturn sign * mantissa * pow2(-126 - 23);\n\t\t}\n\n\t\treturn sign * (1 + mantissa * pow2(-23)) * pow2(exponent);\n\t},\n\n\t_get64: function (Type, byteOffset, littleEndian) {\n\t\tlittleEndian = defined(littleEndian, this._littleEndian);\n\t\tbyteOffset = defined(byteOffset, this._offset);\n\n\t\tvar parts = littleEndian ? [0, 4] : [4, 0];\n\n\t\tfor (var i = 0; i < 2; i++) {\n\t\t\tparts[i] = this.getUint32(byteOffset + parts[i], littleEndian);\n\t\t}\n\n\t\tthis._offset = byteOffset + 8;\n\n\t\treturn new Type(parts[0], parts[1]);\n\t},\n\n\tgetInt64: function (byteOffset, littleEndian) {\n\t\treturn this._get64(Int64, byteOffset, littleEndian);\n\t},\n\n\tgetUint64: function (byteOffset, littleEndian) {\n\t\treturn this._get64(Uint64, byteOffset, littleEndian);\n\t},\n\n\t_getInt32: function (byteOffset, littleEndian) {\n\t\tvar b = this._getBytes(4, byteOffset, littleEndian);\n\t\treturn (b[3] << 24) | (b[2] << 16) | (b[1] << 8) | b[0];\n\t},\n\n\t_getUint32: function (byteOffset, littleEndian) {\n\t\treturn this._getInt32(byteOffset, littleEndian) >>> 0;\n\t},\n\n\t_getInt16: function (byteOffset, littleEndian) {\n\t\treturn (this._getUint16(byteOffset, littleEndian) << 16) >> 16;\n\t},\n\n\t_getUint16: function (byteOffset, littleEndian) {\n\t\tvar b = this._getBytes(2, byteOffset, littleEndian);\n\t\treturn (b[1] << 8) | b[0];\n\t},\n\n\t_getInt8: function (byteOffset) {\n\t\treturn (this._getUint8(byteOffset) << 24) >> 24;\n\t},\n\n\t_getUint8: function (byteOffset) {\n\t\treturn this._getBytes(1, byteOffset)[0];\n\t},\n\n\t_getBitRangeData: function (bitLength, byteOffset) {\n\t\tvar startBit = (defined(byteOffset, this._offset) << 3) + this._bitOffset,\n\t\t\tendBit = startBit + bitLength,\n\t\t\tstart = startBit >>> 3,\n\t\t\tend = (endBit + 7) >>> 3,\n\t\t\tb = this._getBytes(end - start, start, true),\n\t\t\twideValue = 0;\n\n\t\t/* jshint boss: true */\n\t\tif (this._bitOffset = endBit & 7) {\n\t\t\tthis._bitOffset -= 8;\n\t\t}\n\n\t\tfor (var i = 0, length = b.length; i < length; i++) {\n\t\t\twideValue = (wideValue << 8) | b[i];\n\t\t}\n\n\t\treturn {\n\t\t\tstart: start,\n\t\t\tbytes: b,\n\t\t\twideValue: wideValue\n\t\t};\n\t},\n\n\tgetSigned: function (bitLength, byteOffset) {\n\t\tvar shift = 32 - bitLength;\n\t\treturn (this.getUnsigned(bitLength, byteOffset) << shift) >> shift;\n\t},\n\n\tgetUnsigned: function (bitLength, byteOffset) {\n\t\tvar value = this._getBitRangeData(bitLength, byteOffset).wideValue >>> -this._bitOffset;\n\t\treturn bitLength < 32 ? (value & ~(-1 << bitLength)) : value;\n\t},\n\n\t_setBinaryFloat: function (byteOffset, value, mantSize, expSize, littleEndian) {\n\t\tvar signBit = value < 0 ? 1 : 0,\n\t\t\texponent,\n\t\t\tmantissa,\n\t\t\teMax = ~(-1 << (expSize - 1)),\n\t\t\teMin = 1 - eMax;\n\n\t\tif (value < 0) {\n\t\t\tvalue = -value;\n\t\t}\n\n\t\tif (value === 0) {\n\t\t\texponent = 0;\n\t\t\tmantissa = 0;\n\t\t} else if (isNaN(value)) {\n\t\t\texponent = 2 * eMax + 1;\n\t\t\tmantissa = 1;\n\t\t} else if (value === Infinity) {\n\t\t\texponent = 2 * eMax + 1;\n\t\t\tmantissa = 0;\n\t\t} else {\n\t\t\texponent = Math.floor(Math.log(value) / Math.LN2);\n\t\t\tif (exponent >= eMin && exponent <= eMax) {\n\t\t\t\tmantissa = Math.floor((value * pow2(-exponent) - 1) * pow2(mantSize));\n\t\t\t\texponent += eMax;\n\t\t\t} else {\n\t\t\t\tmantissa = Math.floor(value / pow2(eMin - mantSize));\n\t\t\t\texponent = 0;\n\t\t\t}\n\t\t}\n\n\t\tvar b = [];\n\t\twhile (mantSize >= 8) {\n\t\t\tb.push(mantissa % 256);\n\t\t\tmantissa = Math.floor(mantissa / 256);\n\t\t\tmantSize -= 8;\n\t\t}\n\t\texponent = (exponent << mantSize) | mantissa;\n\t\texpSize += mantSize;\n\t\twhile (expSize >= 8) {\n\t\t\tb.push(exponent & 0xff);\n\t\t\texponent >>>= 8;\n\t\t\texpSize -= 8;\n\t\t}\n\t\tb.push((signBit << expSize) | exponent);\n\n\t\tthis._setBytes(byteOffset, b, littleEndian);\n\t},\n\n\t_setFloat32: function (byteOffset, value, littleEndian) {\n\t\tthis._setBinaryFloat(byteOffset, value, 23, 8, littleEndian);\n\t},\n\n\t_setFloat64: function (byteOffset, value, littleEndian) {\n\t\tthis._setBinaryFloat(byteOffset, value, 52, 11, littleEndian);\n\t},\n\n\t_set64: function (Type, byteOffset, value, littleEndian) {\n\t\tif (typeof value !== 'object') {\n\t\t\tvalue = Type.fromNumber(value);\n\t\t}\n\n\t\tlittleEndian = defined(littleEndian, this._littleEndian);\n\t\tbyteOffset = defined(byteOffset, this._offset);\n\n\t\tvar parts = littleEndian ? {lo: 0, hi: 4} : {lo: 4, hi: 0};\n\n\t\tfor (var partName in parts) {\n\t\t\tthis.setUint32(byteOffset + parts[partName], value[partName], littleEndian);\n\t\t}\n\n\t\tthis._offset = byteOffset + 8;\n\t},\n\n\tsetInt64: function (byteOffset, value, littleEndian) {\n\t\tthis._set64(Int64, byteOffset, value, littleEndian);\n\t},\n\n\tsetUint64: function (byteOffset, value, littleEndian) {\n\t\tthis._set64(Uint64, byteOffset, value, littleEndian);\n\t},\n\n\t_setUint32: function (byteOffset, value, littleEndian) {\n\t\tthis._setBytes(byteOffset, [\n\t\t\tvalue & 0xff,\n\t\t\t(value >>> 8) & 0xff,\n\t\t\t(value >>> 16) & 0xff,\n\t\t\tvalue >>> 24\n\t\t], littleEndian);\n\t},\n\n\t_setUint16: function (byteOffset, value, littleEndian) {\n\t\tthis._setBytes(byteOffset, [\n\t\t\tvalue & 0xff,\n\t\t\t(value >>> 8) & 0xff\n\t\t], littleEndian);\n\t},\n\n\t_setUint8: function (byteOffset, value) {\n\t\tthis._setBytes(byteOffset, [value & 0xff]);\n\t},\n\n\tsetUnsigned: function (byteOffset, value, bitLength) {\n\t\tvar data = this._getBitRangeData(bitLength, byteOffset),\n\t\t\twideValue = data.wideValue,\n\t\t\tb = data.bytes;\n\n\t\twideValue &= ~(~(-1 << bitLength) << -this._bitOffset); // clearing bit range before binary \"or\"\n\t\twideValue |= (bitLength < 32 ? (value & ~(-1 << bitLength)) : value) << -this._bitOffset; // setting bits\n\n\t\tfor (var i = b.length - 1; i >= 0; i--) {\n\t\t\tb[i] = wideValue & 0xff;\n\t\t\twideValue >>>= 8;\n\t\t}\n\n\t\tthis._setBytes(data.start, b, true);\n\t}\n};\n\nif (NODE) {\n\tvar nodeNaming = {\n\t\t'Int8': 'Int8',\n\t\t'Int16': 'Int16',\n\t\t'Int32': 'Int32',\n\t\t'Uint8': 'UInt8',\n\t\t'Uint16': 'UInt16',\n\t\t'Uint32': 'UInt32',\n\t\t'Float32': 'Float',\n\t\t'Float64': 'Double'\n\t};\n\n\tproto._nodeBufferAction = function (type, isReadAction, byteOffset, littleEndian, value) {\n\t\t// Move the internal offset forward\n\t\tthis._offset = byteOffset + dataTypes[type];\n\t\tvar nodeName = nodeNaming[type] + ((type === 'Int8' || type === 'Uint8') ? '' : littleEndian ? 'LE' : 'BE');\n\t\tbyteOffset += this.byteOffset;\n\t\treturn isReadAction ? this.buffer['read' + nodeName](byteOffset) : this.buffer['write' + nodeName](value, byteOffset);\n\t};\n}\n\nfor (var type in dataTypes) {\n\t/* jshint loopfunc: true */\n\t(function (type) {\n\t\tproto['get' + type] = function (byteOffset, littleEndian) {\n\t\t\treturn this._action(type, true, byteOffset, littleEndian);\n\t\t};\n\t\tproto['set' + type] = function (byteOffset, value, littleEndian) {\n\t\t\tthis._action(type, false, byteOffset, littleEndian, value);\n\t\t};\n\t})(type);\n\t/* jshint loopfunc: false */\n}\n\nproto._setInt32 = proto._setUint32;\nproto._setInt16 = proto._setUint16;\nproto._setInt8 = proto._setUint8;\nproto.setSigned = proto.setUnsigned;\n\nfor (var method in proto) {\n\t/* jshint loopfunc: true */\n\tif (method.slice(0, 3) === 'set') {\n\t\t(function (type) {\n\t\t\tproto['write' + type] = function () {\n\t\t\t\tArray.prototype.unshift.call(arguments, undefined);\n\t\t\t\tthis['set' + type].apply(this, arguments);\n\t\t\t};\n\t\t})(method.slice(3));\n\t}\n\t/* jshint loopfunc: false */\n}\n"],"names":["is","obj","Ctor","constructor","Object","prototype","toString","call","name","arrayFrom","arrayLike","forceCopy","Array","slice","defined","value","defaultValue","undefined","jDataView","buffer","byteOffset","byteLength","littleEndian","result","_littleEndian","this","wrapBuffer","_isArrayBuffer","compatibility","ArrayBuffer","_isPixelData","PixelData","CanvasPixelArray","_isDataView","DataView","_isNodeBuffer","NODE","TypeError","bufferLength","length","_offset","_bitOffset","_view","_checkBounds","_engineAction","_dataViewAction","_arrayBufferAction","_arrayAction","getCharCodes","string","codes","Uint8Array","i","charCodeAt","pow2","n","Math","pow","Uint64","lo","hi","Int64","apply","arguments","numToDigits","num","digits","split","reverse","add","x","y","z","max","carry","zi","push","floor","ctx","self","NodeBuffer","TextEncoder","TextDecoder","context2d","document","createElement","getContext","createPixelData","data","createImageData","dataTypes","Int8","Int16","Int32","Uint8","Uint16","Uint32","Float32","Float64","view","from","valueOf","fromNumber","number","create","unsigned","Number","hiArray","loArray","str","proto","maxLength","RangeError","_action","type","isReadAction","typedArray","size","TypedArray","bytes","getBytes","_setBytes","_getBytes","toArray","set","setBytes","getString","encoding","decode","String","fromCharCode","decodeURIComponent","escape","setString","subString","encode","unescape","encodeURIComponent","getChar","setChar","character","tell","seek","skip","start","end","normalizeOffset","offset","alignBy","byteCount","_getFloat64","b","sign","exponent","mantissa","NaN","Infinity","_getFloat32","_get64","Type","parts","getUint32","getInt64","getUint64","_getInt32","_getUint32","_getInt16","_getUint16","_getInt8","_getUint8","_getBitRangeData","bitLength","startBit","endBit","wideValue","getSigned","shift","getUnsigned","_setBinaryFloat","mantSize","expSize","signBit","eMax","eMin","isNaN","log","LN2","_setFloat32","_setFloat64","_set64","partName","setUint32","setInt64","setUint64","_setUint32","_setUint16","_setUint8","setUnsigned","_setInt32","_setInt16","_setInt8","setSigned","method","unshift"],"mappings":"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"}